// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"AP//GrUa3AHMAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
