// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
