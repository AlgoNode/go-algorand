// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"8znIWs85ejR5MLr6fwEAAP//IV1/sD/MAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
