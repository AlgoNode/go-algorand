// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/go-algorand/data/basics"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address basics.Address, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address basics.Address, applicationId basics.AppIndex, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address basics.Address, assetId basics.AssetIndex, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId basics.AppIndex) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId basics.AppIndex, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId basics.AssetIndex) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round basics.Round, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round basics.Round) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round basics.Round) error
	// Get all of the logs from outer and inner app calls in the given round
	// (GET /v2/blocks/{round}/logs)
	GetBlockLogs(ctx echo.Context, round basics.Round) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round basics.Round, txid string, params GetTransactionProofParams) error
	// Get the top level transaction IDs for the block on the given round.
	// (GET /v2/blocks/{round}/txids)
	GetBlockTxids(ctx echo.Context, round basics.Round) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round basics.Round, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round basics.Round, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round basics.Round) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round basics.Round) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address basics.Address

	err = runtime.BindStyledParameterWithOptions("simple", "address", ctx.Param("address"), &address, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId basics.AppIndex

	err = runtime.BindStyledParameterWithOptions("simple", "application-id", ctx.Param("application-id"), &applicationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId basics.AssetIndex

	err = runtime.BindStyledParameterWithOptions("simple", "asset-id", ctx.Param("asset-id"), &assetId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "header-only" -------------

	err = runtime.BindQueryParameter("form", true, false, "header-only", ctx.QueryParams(), &params.HeaderOnly)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter header-only: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetBlockLogs converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockLogs(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockLogs(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithOptions("simple", "txid", ctx.Param("txid"), &txid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTxids converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTxids(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTxids(ctx, round)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithOptions("simple", "offset", ctx.Param("offset"), &offset, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round basics.Round

	err = runtime.BindStyledParameterWithOptions("simple", "round", ctx.Param("round"), &round, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/logs", wrapper.GetBlockLogs, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/txids", wrapper.GetBlockTxids, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
